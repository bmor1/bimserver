#summary Design for object level modifications

[http://code.google.com/p/bimserver/issues/detail?id=78 Issue]

= Introduction =

Until now the only way to change models in the BIMserver database would be to use the Service Interface (via SOAP for example) and upload new IFC files. Each file would become a new revision in the selected project.

Because IFC files tend to get very large, and usually only a fraction of the model has changed, it would be better to only send the actual changes instead of the complete new situation.

This page describes the planned implementation of a set of features making this possible.

= Previous ideas / implementations =

A while ago there has been an implementation of ChangeSets, which were xml files describing the changes made with tags like "Addition", "Modification", "Removal". One disadvantage of this would be that a client has to keep track of all changes made, and at the end create a changeset and send it to the server. With this approach concurrent modification of the same object would be detected very late.

We have also thought about using the IFC STEP format to describe changes, but because the IFC STEP format is meant for describing complete models it is impossible to reference objects not described in the file without breaking it (not confirming to the rules).

= Current idea =

A second Service Interface will be created, containing the following methods for transaction management:

||* Method *||* Return type *||* Parameters *||* Description *||
||startTransaction||int (transaction id)||None||Start a transaction||
||commitTransaction||void||int (transaction id)||Commit a transaction||
||abortTransaction||void||int (transaction id)||Abort a transaction||

Transaction management is needed because we don't want to create a new revision for each change; the user should be able to indicate which changes belong to the same atomic commit.

== Generic access ==

The following methods will be added for the actual generic modifications:

||* Method *||* Return type *||* Parameters *||* Description *||
||addObject||void||String (type), List<Object> (values)||Create a new object||
||removeObject||void||long (object id)||Remove an object||
||setAttribute||void||long (object id), String (attribute name), Object (value)||Set a simple attribute||
||setReference||void||long (object id), String (reference name), long (oid of referenced object)||Set a single reference||
||unsetAttribute||void||long (object id), String (attribute name)||Unset a simple attribute (null)||
||unsetReference||void||long (object id), String (reference name)||Unset a single reference||
||addAttribute||void||long (object id), String (attribute name), Object (value)||Add a simple value to a list of attributes||
||addReference||void||long (object id), String (reference name), long (object id of referenced object||Add a reference to a list||

Examples:

{{{
// Creating a new window
Set<Object> parameters = new LinkedHashSet<Object>();
parameters.add("1dzyWEOh99jRUBVYP$exmF");
parameters.add(5);
parameters.add("Window 152");
// etc...
service.addObject("IfcWindow", parameters);

// Setting an attribute
service.setAttribute(20, "OverallHeight", 2.00);
}}}

== Domain specific access ==

Besides generic access the idea is to also implement a domain specific way to modify models. The domain in this case would be IFC, but this can later be extended to other models.

Advantages:
  * Less work for all implementers, the SOAP WSDL (or protocol buffers .proto file) would generate a complete interface for all objects/attributes/references for all kinds of languages.
  * The generated interface would be type safe
  * The generated interface could be augmented with documentation

There are two possible ways to do this, the Object Oriented way and a more functional way, both could co-exist.

=== Object Oriented ===

||* Method *||* Return type *||* Parameters *||* Description *||
||createIfcWindow||void||IfcWindow||Creates an IfcWindow with all fields set||
||updateIfcWindow||void||IfcWindow||Updates all fields with the given values||

Note: This method is probably not feasible because a complete object model would "drag" in all references and their references, essentially sending the complete model, which is what we don't want to do.

=== Functional ===

||* Method *||* Return type *||* Parameters *||* Description *||
||createIfcWindow||void||String (GlobalID), long (OwnerHistory id), String (name), String (description) etc...||Creates an IfcWindow with all fields set||
||setIfcWindow_OverallHeight||void||long (object id of window), float (OverallHeight)||Updates one specific field||